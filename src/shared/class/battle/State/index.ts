import { RunService } from "@rbxts/services";
import { MOVEMENT_COST } from "shared/const";
import { AttackAction, BotType, ClashResult, ClashResultFate, EntityStats, ReadinessIcon, Reality } from "shared/types/battle-types";
import { calculateRealityValue, getDummyStats, requestData, warnWrongSideCall } from "shared/utils";
import Entity from "../Entity";
import HexCell from "../Hex/Cell";
import HexGrid from "../Hex/Grid";
import Pathfinding from "../Pathfinding";


export class Team {
    name: string;
    members: Entity[];

    constructor(name: string, members: Entity[]) {
        this.name = name;
        this.members = members;
    }

    push(...members: Entity[]) {
        for (const member of members) {
            if (!this.members.some((m) => m.stats.id === member.stats.id)) {
                this.members.push(member);
            }
        }
    }
}

export default class State {
    currentRoundEntityID?: number;
    time: number = -1;
    teams: Team[] = [];

    grid: HexGrid;
    gridMin: Vector2;
    gridMax: Vector2;

    constructor(width: number, height: number, worldCenter: Vector3, size: number) {
        this.grid = new HexGrid({
            radius: math.floor(width / 2),
            center: new Vector2(worldCenter.X, worldCenter.Z),
            size,
            name: "BattleGrid",
        });
        const halfWidth = (width * size) / 2;
        const halfHeight = (height * size) / 2;
        this.gridMin = new Vector2(worldCenter.X - halfWidth, worldCenter.Z - halfHeight);
        this.gridMax = new Vector2(worldCenter.X + halfWidth, worldCenter.Z + halfHeight);
    }

    protected placeEntity(entity: Entity, cell: HexCell) {
        if (RunService.IsClient()) {
            warnWrongSideCall("placeEntity");
            return;
        }
        entity.setCell(cell);
    }
    /**
     * Moves an entity to a specified cell along a calculated path.
     *
     * @param entity - The entity to be moved.
     * @param toCell - The destination cell to move the entity to.
     * @param path - An optional pre-calculated path for the entity to follow. If not provided, a path will be calculated.
     * @returns A promise that resolves when the entity has been moved.
     *
     * @remarks
     * - If the entity does not have a current cell, a warning is logged and the function returns early.
     * - The path is calculated using the entity's position and movement cost.
     * - If no path is found, a warning is logged and the function returns early.
     * - If the destination cell is not vacant, the function attempts to find an adjacent vacant cell.
     * - The GUI is updated to reflect the calculated path.
     */
    protected async moveEntity(entity: Entity, toCell: HexCell, path?: Vector2[]): Promise<void> {
        //#region 
        if (!entity.cell) {
            warn("moveEntity: Entity has no cell");
            return;
        }
        //#endregion
        const lim = math.floor(entity.get('pos') / MOVEMENT_COST);
        const calculatedPath =
            path ??
            new Pathfinding({
                grid: this.grid,
                start: entity.cell.qr(),
                dest: toCell.qr(),
                limit: lim,
            }).begin();
        //#region 
        if (calculatedPath.size() === 0) {
            warn(`Move Entity: No path found from ${entity.cell.qr().X}, ${entity.cell.qr().Y} to ${toCell.qr().X}, ${toCell.qr().Y}`,);
            return;
        }
        //#endregion
        let destination = toCell;
        if (!toCell.isVacant()) {
            const adjacentCell = this.grid.getCell(calculatedPath[calculatedPath.size() - 1]);
            if (adjacentCell?.isVacant()) {
                destination = adjacentCell;
            } else {
                warn("Move Entity: Destination cell and adjacent cell are not vacant");
                return;
            }
        }

        // this.gui.mountOrUpdateGlow(calculatedPath.mapFiltered((v) => this.grid.getCell(v)));
        return entity.moveToCell(destination, calculatedPath.mapFiltered((v) => this.grid.getCell(v)));
    }

    /**
     * Initializes the teams for the battle.
     *
     * @param teamMap - A record where the key is the team name and the value is an array of players belonging to that team.
     *
     * This method iterates over the provided team map, processes each player to create an `Entity` object, and then
     * groups these entities into `Team` objects which are added to the `teams` array.
     *
     * Each player is mapped to an `Entity` object by fetching their character stats and other relevant information.
     * If the character stats are not found, a warning is logged and the player is skipped.
     *
     * @remarks
     * - The `playerID` is generated by adding a random number to the player's `UserId`.
     * - If the player's `UserId` is 0, the entity is marked as an enemy bot.
     * - The `characterID` is currently hardcoded as 'entity_adalbrecht' for temporary purposes.
     */
    private initializeTeams(teamMap: Record<string, Player[]>) {
        for (const [teamName, playerList] of pairs(teamMap)) {
            const members = playerList
                .mapFiltered((player) => {
                    // const characterID = player.Character ? player.Character.Name : "default_character";
                    const characterID = 'entity_adalbrecht'; // temp
                    const characterStats = requestData(player, "characterStats", characterID) as EntityStats;
                    if (!characterStats) {
                        warn(`Character [${characterID}] not found for [${player.Name}]`);
                        return undefined;
                    }
                    return new Entity({
                        playerID: player.UserId,
                        stats: characterStats,
                        pos: 0,
                        org: 0,
                        hip: 0,
                        sta: 0,
                        name: player.Name,
                        team: teamName,
                        botType: player.UserId === -1 ? BotType.Enemy : undefined,
                    });
                })
                .filter((entity): entity is Entity => entity !== undefined);
            this.teams.push(new Team(teamName, members));
        }
    }

    private initializeEntitiesPositions() {
        const allEntities = this.getAllEntities();
        const vacantCells = this.grid.cells.filter((cell) => cell.isVacant());

        if (vacantCells.size() < allEntities.size()) {
            warn("Not enough vacant cells to spawn all entities", vacantCells.size(), allEntities.size());
            return;
        }

        for (const entity of allEntities) {
            if (entity.cell) continue;

            const i = math.random(0, vacantCells.size() - 1)
            const randomCell = vacantCells[i];
            if (randomCell) {
                vacantCells.remove(i)
                entity.setCell(randomCell);
            }
        }
    }

    public initializeNumbers(teamMap: Record<string, Player[]>) {
        this.grid.initialise();
        this.initializeTeams(teamMap);
        this.initializeEntitiesPositions();
        this.initializeTestingDummies(); // temp
    }

    private initializeTestingDummies() {
        const dummy = new Entity({
            stats: getDummyStats(),
            playerID: -1,
            hip: 0,
            pos: 0,
            org: 999,
            sta: 999,
        })
        this.teams.push(new Team("Test", [dummy]));
        this.placeEntity(dummy, this.grid.cells.find((c) => c.isVacant())!);
    }


    public getAllEntities(): Entity[] {
        return this.teams.map((team) => team.members).reduce<Entity[]>((acc, val) => [...acc, ...val], []);
    }

    public applyClash(attackAction: AttackAction) {
        const clashResult = attackAction.clashResult;
        if (!clashResult) {
            warn("applyClash: Clash result not found");
            return;
        }
        print(`Clash Result: ${clashResult.fate} | Damage: ${clashResult.damage}`);
        attackAction.executed = true;
        attackAction.ability.target.damage(clashResult.damage);
    }

    public clash(attackAction: AttackAction): ClashResult {
        const { using: attacker, target, acc } = attackAction.ability;
        print(`Attacker: ${attacker.name} | Target: ${target.name} | Accuracy: ${acc}`);

        let fate: ClashResultFate = "Miss";
        let damage = 0;

        const hitRoll = math.random(1, 100);
        const hitChance = acc - calculateRealityValue(Reality.Maneuver, target);
        const critChance = calculateRealityValue(Reality.Precision, attacker);

        const abilityDamage = attackAction.ability.calculateDamage();
        const minDamage = abilityDamage * 0.5;
        const maxDamage = abilityDamage;

        if (hitRoll <= hitChance) {
            if (hitRoll <= hitChance * 0.1 + critChance) {
                damage = math.random((minDamage + maxDamage) / 2, maxDamage) * 2;
                fate = "CRIT";
            } else {
                damage = math.random(minDamage, maxDamage);
                fate = "Hit";
            }
        }

        damage = math.clamp(damage, 0, 1000);
        return { damage, u_damage: damage, fate, roll: hitRoll };
    }

    public findEntity(playerID: number): Entity | undefined {
        return this.getAllEntities().find((entity) => entity.playerID === playerID);
    }

    //#region readiness
    private calculateReadinessIncrement(entity: Entity) {
        return entity.stats.spd + math.random(-0.1, 0.1) * entity.stats.spd;
    }

    private iterateReadinessGauntlet(entities: Entity[]) {
        for (const entity of entities) {
            entity.change('pos', math.clamp(entity.get('pos') + this.calculateReadinessIncrement(entity), 0, 100));
        }
    }

    public runReadinessGauntlet() {
        const entities = this.getAllEntities();
        if (entities.size() === 0) return;

        while (!entities.some((e) => e.get('pos') >= 100)) {
            this.iterateReadinessGauntlet(entities);
        }

        const winner = entities.sort((a, b) => a.get('pos') - b.get('pos') > 0)[0];
        return winner;
    }

    protected getReadinessIcons(): ReadinessIcon[] {
        return this.getAllEntities().map((entity) => ({
            playerID: entity.playerID,
            iconUrl: "rbxassetid://18915919565",
            readiness: entity.getState('pos')
        }));
    }
    //#endregion
}